"""
Numerical exterior derivative computations.

Implements the numerical exterior derivative algorithm from https://arxiv.org/abs/2510.00999
for computing d(omega) on Calabi-Yau manifolds.
"""

import numpy as np


def sample_numerical_kform_neighborhood_val(sampler, point, epsilon=1e-12, 
                                           find_max_dQ_coords_fn=None, 
                                           quintic_solver_fn=None):
    """
    Sample numerical values of a k-form at a (cubic) neighborhood of a point.
    
    Parameters
    ----------
    sampler : callable
        Function to sample the k-form value at a point
    point : ndarray, shape (10,)
        Point at which to sample (center of a cube) in real coordinates (x1,...,x5,y1,...,y5)
    epsilon : float
        Distance from the point to the neighborhood points
    find_max_dQ_coords_fn : callable, optional
        Function to find max |dQ/dz| coordinate. If None, uses argmax strategy.
    quintic_solver_fn : callable, optional
        Function to solve quintic constraint. If None, uses standard quintic solver.
        
    Returns
    -------
    dict
        6-dimensional dictionary with keys '0' to '6', where '0' is the center point 
        and '1' to '6' are the ±epsilon * canonical basis vectors
    """
    # Convert to complex coordinates
    point_cc = point[0:5] + 1.j*point[5:]
    
    # Find coordinates to drop
    if find_max_dQ_coords_fn is not None:
        drop_max = int(find_max_dQ_coords_fn(point_cc))
    else:
        # Simple fallback: find coordinate farthest from 1
        drop_max = int(np.argmax(np.abs(point_cc - 1)))
    
    drop_one = int(np.argmin(np.abs(point_cc - 1)))
    
    # Remove dropped coordinates
    p_cc = np.delete(point_cc, [drop_max, drop_one])
    p = np.concatenate([p_cc.real, p_cc.imag])
    
    # Use provided quintic solver or default
    if quintic_solver_fn is None:
        quintic_solver_fn = lambda p_reduced, dm, do: quintic_solver(p_reduced, dm, do)
    
    # Generate directions
    directions = [np.array(np.eye(6, dtype=float)[i]) for i in range(6)]
    
    values = {
        "0": [sampler(quintic_solver_fn(p, drop_max, drop_one))],
        "1": [sampler(quintic_solver_fn(p - epsilon*directions[0], drop_max, drop_one)), 
              sampler(quintic_solver_fn(p + epsilon*directions[0], drop_max, drop_one))],
        "2": [sampler(quintic_solver_fn(p - epsilon*directions[1], drop_max, drop_one)), 
              sampler(quintic_solver_fn(p + epsilon*directions[1], drop_max, drop_one))],
        "3": [sampler(quintic_solver_fn(p - epsilon*directions[2], drop_max, drop_one)), 
              sampler(quintic_solver_fn(p + epsilon*directions[2], drop_max, drop_one))],
        "4": [sampler(quintic_solver_fn(p - epsilon*directions[3], drop_max, drop_one)), 
              sampler(quintic_solver_fn(p + epsilon*directions[3], drop_max, drop_one))],
        "5": [sampler(quintic_solver_fn(p - epsilon*directions[4], drop_max, drop_one)), 
              sampler(quintic_solver_fn(p + epsilon*directions[4], drop_max, drop_one))],
        "6": [sampler(quintic_solver_fn(p - epsilon*directions[5], drop_max, drop_one)), 
              sampler(quintic_solver_fn(p + epsilon*directions[5], drop_max, drop_one))],
    }
    
    return values


def quintic_solver(p, drop_max, drop_one):
    """
    Solve quintic constraint to reconstruct full 10D point.
    
    For the quintic CY: sum(z_i^5) + 1 = 0
    
    Parameters
    ----------
    p : ndarray, shape (6,)
        Reduced coordinates (3 real + 3 imaginary, excluding drop_max and drop_one)
    drop_max : int
        Index of coordinate to solve for (0-4)
    drop_one : int
        Index of coordinate set to 1 (0-4)
        
    Returns
    -------
    ndarray, shape (1, 10)
        Full 10D point in real coordinates
    """
    # Reconstruct complex coordinates
    p_cc = p[0:3] + 1.j*p[3:]
    
    # Solve quintic: z_drop_max = (-1 - sum(other z_i^5))^(1/5)
    new_dependent = (-1 - p_cc[0]**5 - p_cc[1]**5 - p_cc[2]**5)**(1/5)
    
    # Build full coordinate array
    ret = [None] * 10
    ret[drop_one] = 1.0
    ret[drop_one + 5] = 0.0
    
    ret[drop_max] = float(new_dependent.real)
    ret[drop_max + 5] = float(new_dependent.imag)
    
    # Fill in the remaining coordinates
    j = 0
    for i in range(5):
        if ret[i] is None:
            ret[i] = float(p[j])
            ret[i + 5] = float(p[j + 3])
            j += 1
    
    return np.expand_dims(np.array(ret, dtype=np.float64), axis=0)


def numerical_d(k_form_neighborhood_vals, epsilon=1e-12):
    """
    Compute the numerical exterior derivative of a k-form at a point using neighborhood values.
    
    Uses the formula: d\omega_p(X_0, ..., X_k) ≈ (1/vol(σ)) ∫_{∂σ} ω
    where σ is a small k-dimensional block generated by X_0, ..., X_k.
    
    For Ricci-flat manifolds: g_ij(x) = δ_ij + O(|x|^3), so vol(σ) ≈ (2ε)^k
    
    Parameters
    ----------
    k_form_neighborhood_vals : dict
        Dictionary of neighborhood values of the k-form
    epsilon : float
        Small value to approximate the derivative
        
    Returns
    -------
    ndarray
        Numerical exterior derivative of the k-form at the center point
        
    Notes
    -----
    Sign convention follows Acker's book: (-1) × standard convention
    """
    k = len(k_form_neighborhood_vals["0"][0].shape)
    
    # 0-form (scalar field)
    if k == 0: 
        dw = np.zeros(6)
        for i in range(6):
            dw[i] = (1/(2*epsilon)) * (k_form_neighborhood_vals[str(i+1)][1] - 
                                       k_form_neighborhood_vals[str(i+1)][0])
        return dw
    
    # 1-form
    elif k == 1:
        dw = np.zeros((6, 6))
        for i in range(6):
            for j in range(6):
                if i != j:
                    dw[i, j] = (1/(2*epsilon)) * (
                        k_form_neighborhood_vals[str(j+1)][0][i] +
                        k_form_neighborhood_vals[str(i+1)][1][j] -
                        k_form_neighborhood_vals[str(j+1)][1][i] -
                        k_form_neighborhood_vals[str(i+1)][0][j]
                    )
        return dw
    
    # 2-form
    elif k == 2:
        dw = np.zeros((6, 6, 6))
        for i in range(6):
            for j in range(6):
                for k_idx in range(6):
                    if i != j and j != k_idx and i != k_idx:
                        dw[i, j, k_idx] = (1/(2*epsilon)) * (
                            +k_form_neighborhood_vals[str(i+1)][1][j, k_idx] -
                            k_form_neighborhood_vals[str(i+1)][0][j, k_idx] -
                            k_form_neighborhood_vals[str(j+1)][1][i, k_idx] +
                            k_form_neighborhood_vals[str(j+1)][0][i, k_idx] +
                            k_form_neighborhood_vals[str(k_idx+1)][1][i, j] -
                            k_form_neighborhood_vals[str(k_idx+1)][0][i, j]
                        )
        return dw

    elif k >= 3:
        raise NotImplementedError(f"Numerical exterior derivative for {k}-forms (k >= 3) is not implemented.")
    
    else:
        raise ValueError(f"Invalid k-form dimension: k={k}")


def sample_numerical_g2_neighborhood_val(sampler, point, epsilon=1e-12, 
                                        find_max_dQ_coords_fn=None, 
                                        global_rotation_epsilon=1e-12,
                                        drop_max=None, drop_one=None):
    """
    Sample numerical values of a G2 form at a neighborhood of a point on the link R^7.
    
    This version includes an additional 7th direction for global phase rotation.
    
    Parameters
    ----------
    sampler : callable
        Function to sample the G2 form value at a point
    point : ndarray, shape (10,)
        Point in R^10 (real representation of CY coordinates)
    epsilon : float
        Distance for local coordinate perturbations
    find_max_dQ_coords_fn : callable, optional
        Function to find max |dQ/dz| coordinate
    global_rotation_epsilon : float
        Epsilon for global phase rotation
    drop_max : int, optional
        Index of coordinate to drop (if None, will be computed)
    drop_one : int, optional
        Index of coordinate to normalize to 1 (if None, will be computed)
        
    Returns
    -------
    dict
        7-dimensional dictionary with keys '0' to '7', where '0' is the center point,
        '1' to '6' are the ±epsilon * canonical basis vectors in reduced coordinates,
        and '7' is for ±global_rotation_epsilon phase rotation
    """
    point_cc = point[0:5] + 1.j*point[5:]
    
    # Find coordinates to drop (use provided values if available)
    if drop_max is None:
        if find_max_dQ_coords_fn is not None:
            drop_max = int(find_max_dQ_coords_fn(point_cc))
        else:
            drop_max = int(np.argmax(np.abs(point_cc - 1)))
    
    if drop_one is None:
        drop_one = int(np.argmin(np.abs(point_cc - 1)))
    
    # Reduced coordinates
    p_cc = np.delete(point_cc, [drop_max, drop_one])
    p = np.concatenate([p_cc.real, p_cc.imag])
    
    # Generate directions in 6D reduced space
    directions = [np.array(np.eye(6, dtype=float)[i]) for i in range(6)]
    
    # Rotated versions for 7th direction
    X_rotated_plus = point_cc * np.exp(1j * global_rotation_epsilon)
    aux_one = int(np.argmin(np.abs(X_rotated_plus - 1)))
    X_rotated_plus = X_rotated_plus / X_rotated_plus[aux_one]
    X_rotated_plus[aux_one] = 1.0
    X_rotated_plus = np.concatenate([X_rotated_plus.real, X_rotated_plus.imag])
    
    X_rotated_minus = point_cc * np.exp(-1j * global_rotation_epsilon)
    aux_one = int(np.argmin(np.abs(X_rotated_minus - 1)))
    X_rotated_minus = X_rotated_minus / X_rotated_minus[aux_one]
    X_rotated_minus[aux_one] = 1.0
    X_rotated_minus = np.concatenate([X_rotated_minus.real, X_rotated_minus.imag])
    
    # Sample at all positions
    v0 = sampler(quintic_solver(p, drop_max, drop_one)[0])
    v1p = sampler(quintic_solver(p + epsilon*directions[0], drop_max, drop_one)[0])
    v1m = sampler(quintic_solver(p - epsilon*directions[0], drop_max, drop_one)[0])
    v2p = sampler(quintic_solver(p + epsilon*directions[1], drop_max, drop_one)[0])
    v2m = sampler(quintic_solver(p - epsilon*directions[1], drop_max, drop_one)[0])
    v3p = sampler(quintic_solver(p + epsilon*directions[2], drop_max, drop_one)[0])
    v3m = sampler(quintic_solver(p - epsilon*directions[2], drop_max, drop_one)[0])
    v4p = sampler(quintic_solver(p + epsilon*directions[3], drop_max, drop_one)[0])
    v4m = sampler(quintic_solver(p - epsilon*directions[3], drop_max, drop_one)[0])
    v5p = sampler(quintic_solver(p + epsilon*directions[4], drop_max, drop_one)[0])
    v5m = sampler(quintic_solver(p - epsilon*directions[4], drop_max, drop_one)[0])
    v6p = sampler(quintic_solver(p + epsilon*directions[5], drop_max, drop_one)[0])
    v6m = sampler(quintic_solver(p - epsilon*directions[5], drop_max, drop_one)[0])
    v7p = sampler(X_rotated_plus)
    v7m = sampler(X_rotated_minus)
    
    values = {
        "0": [v0],
        "1": [v1m, v1p],
        "2": [v2m, v2p],
        "3": [v3m, v3p], 
        "4": [v4m, v4p], 
        "5": [v5m, v5p], 
        "6": [v6m, v6p],
        "7": [v7m, v7p]
    }
    
    return values


def numerical_d_g2(k_form_neighborhood_vals, epsilon=1e-12):
    """
    Compute the numerical exterior derivative for G2 forms on R^7 (including rotation direction).
    
    Supports 0-forms through 4-forms on the 7-dimensional link manifold.
    
    Parameters
    ----------
    k_form_neighborhood_vals : dict
        Dictionary of neighborhood values (keys '0' to '7')
    epsilon : float
        Small value for derivative approximation
        
    Returns
    -------
    ndarray
        Numerical exterior derivative of the k-form
    """
    k = len(k_form_neighborhood_vals["0"][0].shape)
    
    # 0-form (scalar field)
    if k == 0: 
        dw = np.zeros(7)
        for i in range(7):
            dw[i] = (1/(2*epsilon)) * (k_form_neighborhood_vals[str(i+1)][1] - 
                                       k_form_neighborhood_vals[str(i+1)][0])
        return dw
    
    # 1-form
    elif k == 1:
        dw = np.zeros((7, 7))
        for i in range(7):
            for j in range(7):
                if i != j:
                    dw[i, j] = (1/(2*epsilon)) * (
                        k_form_neighborhood_vals[str(j+1)][0][i] +
                        k_form_neighborhood_vals[str(i+1)][1][j] -
                        k_form_neighborhood_vals[str(j+1)][1][i] -
                        k_form_neighborhood_vals[str(i+1)][0][j]
                    )
        return dw
    
    # 2-form
    elif k == 2:
        dw = np.zeros((7, 7, 7))
        for i in range(7):
            for j in range(7):
                for k_idx in range(7):
                    if i != j and j != k_idx and i != k_idx:
                        dw[i, j, k_idx] = (1/(2*epsilon)) * (
                            +k_form_neighborhood_vals[str(i+1)][1][j, k_idx] -
                            k_form_neighborhood_vals[str(i+1)][0][j, k_idx] -
                            k_form_neighborhood_vals[str(j+1)][1][i, k_idx] +
                            k_form_neighborhood_vals[str(j+1)][0][i, k_idx] +
                            k_form_neighborhood_vals[str(k_idx+1)][1][i, j] -
                            k_form_neighborhood_vals[str(k_idx+1)][0][i, j]
                        )
        return dw
    
    # 3-form
    elif k == 3:
        dw = np.zeros((7, 7, 7, 7))
        for i in range(7):
            for j in range(7):
                for k_idx in range(7):
                    for l in range(7):
                        if (i != j and j != k_idx and k_idx != l and 
                            i != k_idx and i != l and j != l):
                            dw[i, j, k_idx, l] = (1/(2*epsilon)) * (
                                +k_form_neighborhood_vals[str(i+1)][1][j, k_idx, l] -
                                k_form_neighborhood_vals[str(i+1)][0][j, k_idx, l] -
                                k_form_neighborhood_vals[str(j+1)][1][i, k_idx, l] +
                                k_form_neighborhood_vals[str(j+1)][0][i, k_idx, l] +
                                k_form_neighborhood_vals[str(k_idx+1)][1][i, j, l] -
                                k_form_neighborhood_vals[str(k_idx+1)][0][i, j, l] -
                                k_form_neighborhood_vals[str(l+1)][1][i, j, k_idx] +
                                k_form_neighborhood_vals[str(l+1)][0][i, j, k_idx]
                            )
        return dw
    
    # 4-form
    elif k == 4:
        dw = np.zeros((7, 7, 7, 7, 7))
        for i in range(7):
            for j in range(7):
                for k_idx in range(7):
                    for l in range(7):
                        for m in range(7):
                            if (i != j and j != k_idx and k_idx != l and l != m and 
                                i != k_idx and i != l and i != m and j != l and j != m and k_idx != m):
                                dw[i, j, k_idx, l, m] = (1/(2*epsilon)) * (
                                    +k_form_neighborhood_vals[str(i+1)][1][j, k_idx, l, m] -
                                    k_form_neighborhood_vals[str(i+1)][0][j, k_idx, l, m] -
                                    k_form_neighborhood_vals[str(j+1)][1][i, k_idx, l, m] +
                                    k_form_neighborhood_vals[str(j+1)][0][i, k_idx, l, m] +
                                    k_form_neighborhood_vals[str(k_idx+1)][1][i, j, l, m] -
                                    k_form_neighborhood_vals[str(k_idx+1)][0][i, j, l, m] -
                                    k_form_neighborhood_vals[str(l+1)][1][i, j, k_idx, m] +
                                    k_form_neighborhood_vals[str(l+1)][0][i, j, k_idx, m] +
                                    k_form_neighborhood_vals[str(m+1)][1][i, j, k_idx, l] -
                                    k_form_neighborhood_vals[str(m+1)][0][i, j, k_idx, l]
                                )
        return dw
    
    else:
        raise ValueError(f"Numerical exterior derivative for {k}-forms not supported for k={k}")
