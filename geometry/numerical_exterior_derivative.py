"""
Numerical exterior derivative computations.

Implements the numerical exterior derivative algorithm from https://arxiv.org/abs/2510.00999
for computing d(omega) on Calabi-Yau manifolds.
"""

import numpy as np


def sample_numerical_kform_neighborhood_val(sampler, point, epsilon=1e-12, 
                                           find_max_dQ_coords_fn=None, 
                                           quintic_solver_fn=None):
    """
    Sample numerical values of a k-form at a (cubic) neighborhood of a point.
    
    Parameters
    ----------
    sampler : callable
        Function to sample the k-form value at a point
    point : ndarray, shape (10,)
        Point at which to sample (center of a cube) in real coordinates (x1,...,x5,y1,...,y5)
    epsilon : float
        Distance from the point to the neighborhood points
    find_max_dQ_coords_fn : callable, optional
        Function to find max |dQ/dz| coordinate. If None, uses argmax strategy.
    quintic_solver_fn : callable, optional
        Function to solve quintic constraint. If None, uses standard quintic solver.
        
    Returns
    -------
    dict
        6-dimensional dictionary with keys '0' to '6', where '0' is the center point 
        and '1' to '6' are the ±epsilon * canonical basis vectors
    """
    # Convert to complex coordinates
    point_cc = point[0:5] + 1.j*point[5:]
    
    # Find coordinates to drop
    if find_max_dQ_coords_fn is not None:
        drop_max = int(find_max_dQ_coords_fn(point_cc))
    else:
        # Simple fallback: find coordinate farthest from 1
        drop_max = int(np.argmax(np.abs(point_cc - 1)))
    
    drop_one = int(np.argmin(np.abs(point_cc - 1)))
    
    # Remove dropped coordinates
    p_cc = np.delete(point_cc, [drop_max, drop_one])
    p = np.concatenate([p_cc.real, p_cc.imag])
    
    # Use provided quintic solver or default
    if quintic_solver_fn is None:
        quintic_solver_fn = lambda p_reduced, dm, do: quintic_solver(p_reduced, dm, do)
    
    # Generate directions
    directions = [np.array(np.eye(6, dtype=float)[i]) for i in range(6)]
    
    values = {
        "0": [sampler(quintic_solver_fn(p, drop_max, drop_one))],
        "1": [sampler(quintic_solver_fn(p - epsilon*directions[0], drop_max, drop_one)), 
              sampler(quintic_solver_fn(p + epsilon*directions[0], drop_max, drop_one))],
        "2": [sampler(quintic_solver_fn(p - epsilon*directions[1], drop_max, drop_one)), 
              sampler(quintic_solver_fn(p + epsilon*directions[1], drop_max, drop_one))],
        "3": [sampler(quintic_solver_fn(p - epsilon*directions[2], drop_max, drop_one)), 
              sampler(quintic_solver_fn(p + epsilon*directions[2], drop_max, drop_one))],
        "4": [sampler(quintic_solver_fn(p - epsilon*directions[3], drop_max, drop_one)), 
              sampler(quintic_solver_fn(p + epsilon*directions[3], drop_max, drop_one))],
        "5": [sampler(quintic_solver_fn(p - epsilon*directions[4], drop_max, drop_one)), 
              sampler(quintic_solver_fn(p + epsilon*directions[4], drop_max, drop_one))],
        "6": [sampler(quintic_solver_fn(p - epsilon*directions[5], drop_max, drop_one)), 
              sampler(quintic_solver_fn(p + epsilon*directions[5], drop_max, drop_one))],
    }
    
    return values


def quintic_solver(p, drop_max, drop_one):
    """
    Solve quintic constraint to reconstruct full 10D point.
    
    For the quintic CY: sum(z_i^5) + 1 = 0
    
    Parameters
    ----------
    p : ndarray, shape (6,)
        Reduced coordinates (3 real + 3 imaginary, excluding drop_max and drop_one)
    drop_max : int
        Index of coordinate to solve for (0-4)
    drop_one : int
        Index of coordinate set to 1 (0-4)
        
    Returns
    -------
    ndarray, shape (1, 10)
        Full 10D point in real coordinates
    """
    # Reconstruct complex coordinates
    p_cc = p[0:3] + 1.j*p[3:]
    
    # Solve quintic: z_drop_max = (-1 - sum(other z_i^5))^(1/5)
    new_dependent = (-1 - p_cc[0]**5 - p_cc[1]**5 - p_cc[2]**5)**(1/5)
    
    # Build full coordinate array
    ret = [None] * 10
    ret[drop_one] = 1.0
    ret[drop_one + 5] = 0.0
    
    ret[drop_max] = float(new_dependent.real)
    ret[drop_max + 5] = float(new_dependent.imag)
    
    # Fill in the remaining coordinates
    j = 0
    for i in range(5):
        if ret[i] is None:
            ret[i] = float(p[j])
            ret[i + 5] = float(p[j + 3])
            j += 1
    
    return np.expand_dims(np.array(ret, dtype=np.float64), axis=0)


def numerical_d(k_form_neighborhood_vals, epsilon=1e-12):
    """
    Compute the numerical exterior derivative of a k-form at a point using neighborhood values.
    
    Uses the formula: d\omega_p(X_0, ..., X_k) ≈ (1/vol(σ)) ∫_{∂σ} ω
    where σ is a small k-dimensional block generated by X_0, ..., X_k.
    
    For Ricci-flat manifolds: g_ij(x) = δ_ij + O(|x|^3), so vol(σ) ≈ (2ε)^k
    
    Parameters
    ----------
    k_form_neighborhood_vals : dict
        Dictionary of neighborhood values of the k-form
    epsilon : float
        Small value to approximate the derivative
        
    Returns
    -------
    ndarray
        Numerical exterior derivative of the k-form at the center point
        
    Notes
    -----
    Sign convention follows Acker's book: (-1) × standard convention
    """
    k = len(k_form_neighborhood_vals["0"][0].shape)
    
    # 0-form (scalar field)
    if k == 0: 
        dw = np.zeros(6)
        for i in range(6):
            dw[i] = (1/(2*epsilon)) * (k_form_neighborhood_vals[str(i+1)][1] - 
                                       k_form_neighborhood_vals[str(i+1)][0])
        return dw
    
    # 1-form
    elif k == 1:
        dw = np.zeros((6, 6))
        for i in range(6):
            for j in range(6):
                if i != j:
                    dw[i, j] = (1/(2*epsilon)) * (
                        k_form_neighborhood_vals[str(j+1)][0][i] +
                        k_form_neighborhood_vals[str(i+1)][1][j] -
                        k_form_neighborhood_vals[str(j+1)][1][i] -
                        k_form_neighborhood_vals[str(i+1)][0][j]
                    )
        return dw
    
    # 2-form
    elif k == 2:
        dw = np.zeros((6, 6, 6))
        for i in range(6):
            for j in range(6):
                for k_idx in range(6):
                    if i != j and j != k_idx and i != k_idx:
                        dw[i, j, k_idx] = (1/(2*epsilon)) * (
                            +k_form_neighborhood_vals[str(i+1)][1][j, k_idx] -
                            k_form_neighborhood_vals[str(i+1)][0][j, k_idx] -
                            k_form_neighborhood_vals[str(j+1)][1][i, k_idx] +
                            k_form_neighborhood_vals[str(j+1)][0][i, k_idx] +
                            k_form_neighborhood_vals[str(k_idx+1)][1][i, j] -
                            k_form_neighborhood_vals[str(k_idx+1)][0][i, j]
                        )
        return dw

    elif k >= 3:
        raise NotImplementedError(f"Numerical exterior derivative for {k}-forms (k >= 3) is not implemented.")
    
    else:
        raise ValueError(f"Invalid k-form dimension: k={k}")
